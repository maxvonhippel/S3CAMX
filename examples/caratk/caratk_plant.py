
# Must satisfy the signature
# [t,X,D,P] = sim_function(T,X0,D0,P0,I0);

import numpy as np
from scipy.integrate import ode

import matplotlib.pyplot as PLT


class SIM(object):
    def __init__(self, plt, pvt_init_data):
        pass

    def sim(self, TT, X0, D, P, U, I, property_checker, property_violated_flag):

        Ti = TT[0]
        Tf = TT[1]
        T = Tf - Ti

        X_ = compute(X0, U)

        if property_checker is not None:
            if property_checker(Tf, X_):
                property_violated_flag[0] = True

        dummy_D = np.zeros(D.shape)
        dummy_P = np.zeros(P.shape)
        ret_t = Tf
        ret_X = X_
        ret_D = dummy_D
        ret_P = dummy_P

        # TODO: plotting needs to be fixed
        #PLT.plot(plot_data[0] + Ti, plot_data[1][:, 0])
        #PLT.plot(plot_data[0] + Ti, plot_data[1][:, 1])
        #PLT.plot(plot_data[1][:, 0], plot_data[1][:, 1])
        ##PLT.plot(plot_data[0] + Ti, np.tile(U, plot_data[0].shape))

        return (ret_t, ret_X, ret_D, ret_P)


# State Space Modeling Template
# dx/dt = Ax + Bu
# y = Cx + Du
def compute(x, U):
#(double u,double x_m1_1,double x_m1_2, double w_1,double w_2)
# 	Inputs:
# 		u: Control inputs to the plant
# 		x_m1_1: Previous system state vector, first element
# 		x_m1_2: Previous system state vector, second element
# 		w_1: Random noise to be added on first system state
# 		w_2: Random noise to be added on second system state
# 	Outputs:
# 		SensorValues_1: sensor values generated by the plant, first vector element
# 		SensorValues_2: sensor values generated by the plant, second vector element
# 		SystemState_1: first vector element of the states of the system, required to generate next system state
# 		SystemState_2: second vector element of the states of the system, required to generate next system state
# 	Note:
# 		We are assuming matrix C of the system dynamics is I, to simplify computation. If not the case, output generation needs to be changed
    x_m1_1 = x[0]
    x_m1_2 = x[1]
    u = U[0]
    #//Matrix A of the system dynamics
    a11 = 1
    a12 = 0.01
    a21 = 0
    a22 = 1
    #//Matrix B of the system dynamics
    b11 = 0.0001
    b21 = 0.01
    #//Update system states
    x1 = (a11*x_m1_1 + a12*x_m1_2) + (b11*u)
    x2 = (a21*x_m1_1 + a22*x_m1_2) + (b21*u)
    #//Compute system outputs - looks like this due to C==I
    y1 = x1
    y2 = x2

    y = np.array([y1, y2])
    return y

#     SensorValues_1 = y_1;
#     SensorValues_2 = y_2;
#     SystemState_1 = x_1;
#     SystemState_2 = x_2;


def solout_fun(property_checker, violating_state, plot_data):

    def solout(t, Y):
        plot_data[0] = np.concatenate((plot_data[0], np.array([t])))
        plot_data[1] = np.concatenate((plot_data[1], np.array([Y])))
        return 0

    return solout
